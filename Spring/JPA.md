## DDL이란

- ddl이란? 

    ddl 뜻 : Database Definition Language. 데이터베이스를 정의(다룰 때)할 때 쓰는 언어. 데이터 정의어.
    
    데이터 정의어의 정확한 의미가 무엇일까. 데이터 생성, 수정, 삭제 등 데이터의 전체 골격을 정한다.

## ORM

객체와 관계형 데이터베이스를 매핑하는 것. 프레임워크임.

ORM도 여러종류가 있는데 객체지향 언어에는 대부분 있으나 깊이가 다름.

단순 CRUD만 지원하나 아니면 복잡한 패러다임 불일치도 해결해주나..

자바에서 사용되는 ORM중에서 으뜸은 **Hibernate**임. -> 복잡 패러다임 불일치도 해결.

## JPA

Hibernate 기반의 자바 ORM 기술 표준이 JPA다. JPA는 API 명세임 (인터페이스임)

본 구현은 ORM 프레임워크에 되어있다. 그래서 쓸려면 Hibernate 의존함.

### 왜 JPA여야만 하는가

상속, 연관관계, 객체 그래프 탐색, 비교하기 등의 패러다임 불일치 해결.

- 자바 컬렉션에 저장하는 방식(객체와 참조)과 데이터베이스(테이블과 외래키)에 저장하는 방식 간의 패러다임 불일치를 극복.

- 객체의 패러다임 : 연관관계에서 참조로 다른 Entity를 가져올 수 있다. 외래키는 필요하지 않음.

- 테이블 패러다임 : 연관관계에서 외래키가 필요하다. 참조는 필요 없다.

- 위에꺼는 JPA 없이 코드로 대체 가능한데 객체 그래프 탐색은 개 빡세다..

- 동일성이 보장된다. 

- 같은 데이터 row를 조회해도 일반적으로 JDBC와 SQL문을 통해 조회를 하여 객체에 저장한 것은 동일성 보장이 되지 않는다.

> 동일성 : 객체 인스턴스의 주소 값 비교
> 
> 동등성 : 객체의 값 비교

### 매핑 어노테이션

JPA는 매핑 어노테이션을 분석해서 어떤 객체가 어떤 테이블과 관계되어 있는지 알아냄.

- Entity : 해당 클래스를 테이블과 매핑하겠다. 이 어노테이션이 붙은 클래스의 속성값으로 테이블을 매핑(없으면 만듬)

    - 기본 생성자가 필수(public or protected의 파라미터 X) : JPA가 엔티티 객체 생성 시 기본 생성자를 사용하기 때문. 원래 자바는 생성자가 없으면 기본 생성자를 자동으로 하나 만들지만 다른 생성자가 존재하는 경우에는 기본 생성자를 직접 만들어 주어야 함.

- Table : 엔티티 클래스에 매핑할 테이블 정보. 속성으로 이름을 지정하는 등...
- Id : 엔티티 클래스의 해당 필드를 테이블의 PK와 매핑함. 식별자 필드로 불림.
- Column : 필드를 컬럼에 매핑. 없으면 필드 이름과 컬럼 이름을 매핑함.
- Temporal : 날짜형식 타입 매핑
- Lob : 길이제한 없는 CLOB, BLOB 타입으로 매핑. 사진이나 동영상 등을 인코딩하여 저장할 때 주로 사용됨. 미디어 저장.

### JPA 설정

JPA는 `persistence.xml`로 설정 정보를 관리함. (Maven 프로젝트)

Gradle 프로젝트에서는 `application.properties`로 관리함.

표준 속성

- jdbc.driver : JDBC 드라이버
- jdbc.user : DB 접속 아이디
- jdbc.password : DB 접속 비밀번호
- jdbc.url : DB 접속 URL

방언 설정이 중요함.

DB마다 문법에 차이점이 조금씩 있는데 각자의 기능을 JPA에서 방언(Dialect)이라고 부름.

> [지원 방언 참고](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#database-dialect)

### 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경
- 엔티티 매니저 하나 당 영속성 컨텍스트 하나 담당함.
- 트랜잭션이 시작된다.
- 객체를 영속화하면 영속성 컨텍스트에 들어감. 이 객체는 동일성이 보장된다.
- 동시에 영속성 컨텍스트의 1차 캐시에도 저장됨. 데이터를 불러올 때는 우선적으로 1차 캐시를 확인함. 없으면 DB조회를 한다.
- 동시에 SQL 저장소에 요청 쿼리문을 저장해놓는다.
- 트랜잭션을 커밋할 때 쌓인 SQL을 DB에 전송해서 명령을 수행한다.
- **플러쉬**라는 동작을 하는데 이는 영속성 컨텍스트의 값들과 DB 값들을 동기화하는 것이다. 변경 사항을 DB에 반영함. 쌓인 쿼리문을 날림.
- 동기화 후에 실제 데이터베이스 트랜잭션을 커밋한다.
- 트랜잭션 커밋을 사용하면 성능을 최적화 할 수 있다. 그리고 같은 트랜잭션 범위 안에서 수행되는 결과는 순서에 상관없이 한꺼번에 저장되고 롤백하면 다 취소된다.

- 데이터 수정할 땐 변경 감지 함 (Dirty Checking)
- 영속 컨텍스트에는 엔티티의 스냅샷도 저장해둔다.
- 스냅샷과 엔티티를 비교해서 바뀐 부분을 감지하면 Update 문을 보냄.
- 해당 과정은 플러쉬 과정에서 진행된다. 플러쉬는 **커밋 시 자동 실행** or 직접 실행구문 작성해서 실행(거의 안 씀) or JPQL 쿼리 실행 시 플러쉬 호출
  
- 준영속상태는 영속성 컨텍스트의 기능을 사용할 수 없다. 다른 말로 영속성 컨텍스트에서 해당 엔티티는 관리를 안 한다. 캐쉬에서도 제거되고 INSERT도 안 된다.
- 주로 트랜잭션이 종료될 때 준영속상태로 돌아가고 개발자가 직접 준영속상태로 만들 일은 잘 없다.

정리
1. 1차 캐시 : 조회에서 성능을 올릴 수 있다. 또한 이로인해 동일성 보장
2. 동일성 보장 : 영속성 컨텍스트에 저장되는 엔티티는 1차 캐시에 의해 동일성이 보장됨.
3. 트랜잭션을 지원하는 쓰기 지연 : 트랜잭션 커밋으로 인해 쓰기 지연이 된다. 지연 SQL 버퍼에 저장되고 커밋과 동시에 DB로 쿼리 날림.
4. 지연 로딩 : 나중에 추가함.


## 연관관계 매핑

- **객체의 참조와 테이블의 외래 키를 매핑**
- 엔티티 간에 관계를 맺을 때 사용한다.
- **방향** : 단방향, 양방향이 있다. (이는 객체에서만 그렇고 테이블은 항상 양방향임.)
- **다중성** : 1:1, 1:N, N:1, N:N
- **연관관계의 주인** : 양방향일 때 누가 주인인가.

    단방향 두 개로 서로 참조하게 되는데 외래키는 하나임. 그래서 해당 외래키의 주인을 정해주고 테이블의 외래키를 관리하게함.

    **주인만 읽기, 쓰기, 수정, 삭제가 가능.**

    주인 아니면 읽기만
     가능.

    주인은 `mappedBy`속성을 사용하지 않는다.

    주인이 아니면 `mappedBy`속성을 사용해서 주인을 지정함.

    그럼 어떻게 주인(외래키 관리자)을 정할까?

    - 외래키를 가지고 있는 엔티티에서 관리!
    - 다대일 관계 (유저와 게시글)에서 보면 게시글은 유저id를 외래키로 사용중임. 하지만 유저 입장에서는 외래키를 갖고 있는 게 게시글 리스트의 객체 중 하나이므로 다른 위치에 있다고 본다. 따라서 유저에서 관리함.
    - 비즈니스적으로 생각하지 말자. (더 중요한 쪽이 주인?? 노노)

테이블에서 외래키 하나로 양방향 조인하기

- 멤버 -> 팀
    ```sql
    SELECT *
    FROM MEMBER M
    JOIN TEAM T ON M.TEAM_ID = T.ID
    ```

- 팀 -> 멤버

    ```sql
    SELECT *
    FROM TEAM T
    JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
    ```

객체에서 방향

- 단방향

    ```java
    class A {
        B b;
    }
    class B {}
    ```

- 양방향

    ```java
    class A {
        B b;
    }
    class B {
        A a;
    }
    ```

    - 서로 참조할 수 있다. (A.B, B.A로)


    ```java
    class Post {
        @Id
        private Long post_id;

        @ManyToOne
        @JoinColumn(name = "USER_ID")
        private User user;
    }
    ```

    ```java
    class User {
        @Id
        private Long user_id;

        @OneToMany(mappedBy="user")
        private List<Post> posts;
    }
    ```

    - Post.user에 의해 매핑된다.

- @ManyToOne : N:1 관계 매핑 정보. 

    속성 : optional 연관 엔티티의 존재필수 설정, fetch 글로벌 페치 전략, cascade 영속성 전이, targetEntity 연관된 엔티티 타입정보 설정

- @JoinColumn(name = "") : 외래 키를 매핑할 때 사용.


### JPQL

Java Persistence Qeury Language : 엔티티 객체를 조회하는 객체지향 쿼리

JPA에서 기본적으로 제공하는 메소드(쿼리를 메소드화한 것)로는 처리할 수 없는 복잡한 쿼리문을 날려야 할 때 사용한다.

- JPQL을 쉽게 쓰기 위한 것들 : Criteira, QueryDSL... 빌더 클래스

- Navive Qeury : SQL문 그 자체를 사용함. 근데 이거는 DBMS가 바뀌면 내용 수정할 게 많아질 거 같다. 특정 DB에만 있는 기능을 사용할 때 사용해야한다.

JPA가 JPQL문을 해석하여 적절한 SQL로 바꾼 뒤 DB에 요청한다.

엔티티 대상으로 동작된다. 테이블 속성값으로 동작XX

**문법**

- SELECT, UPDATE DELETE가 있다.

    ```
    select_문 :: = 
        select_절
        from_절
        [where_절]
        [groupby_절]
        [having_절]
        [orderby_절]
    ```

    ```
    update_문 :: = update_절 [where_절]
    ```

    ```
    delete_문 :: = delete_절 [where_절]
    ```

- 엔티티 속성은 대소문자 구분.
- 별칭 필수 

    ```sql
    SELECT m FROM Member AS m
    ```

    AS는 생략 가능

- 반환 타입 알 때: TypeQuery query = em.createQuery...
- 모를 때 : Query query = em.createQuery...

- 이름 기준 파라미터 바인딩 : `:`을 붙여준다.

    ```sql
    SELECT m FROM Member m where m.username=:username
    ```

- 위치 기준 파라미터 바인딩 : `?`다음에 위치 값 준다.

    ```sql
    SELECT m FROM Member m where m.username=?1
    ```


# 의문점

- DAO의 정확한 역할?
- 준영속상태가 필요한 이유? 다른 트랜잭션 범위에서 사용할 때 쓰는 듯 하다. 트랜잭션1에서 동작된 엔티티는 트랜잭션1이 종료되면 준영속상태로 변한다. 그리고 트랜잭션 2를 시작하고 여기서 1에서 사용한 엔티티가 2에서 필요한 상황이 생기면 해당 엔티티를 merge를 하면 트랜잭션 2에서 해당 엔티티를 관리하게 된다. 이 때 1에서 쓴 준영속상태의 엔티티가 영속으로 변하는 게 아니라 새로운 영속 엔티티를 반환하는 것임. 파라미터로 넘어온 준영속 엔티티를 사용해서 새로운 영속성 엔티티를 반환함.